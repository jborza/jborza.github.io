---
layout: post
title:  "FPGA / VGA serial display"
date:   2020-12-13 13:00:00 +0200
categories: hardware
tags: [verilog, serial, doom, vga]
#image: /assets/
published: false
---

For the standard 640x480 VGA video signal, the frequencies of the pulses should be:
Vertical Freq (VS)	Horizontal Freq (HS)
60 Hz (=60 pulses per second)	31.5 kHz (=31500 pulses per second)

Introduction:
http://martin.hinner.info/vga/vga.html

VGA controller:

TODO drawio diagram

`vga_sync` generates timing and synchronization signals
- `hsync` and `vsync` are sent to the monitor, decoded from internal counters
- `pixel_x` and `pixel_y` specify the location of the current pixel
- `video_on` genrated to enable or disable the display (e.g. in display area)

### Horizontal synchronization

hsync is 1 during the 48 left border pixels, 640 display pixels and 16 right border pixels. 
it's 0 during 96 retrace pixels.
in other words, goes low when the counter_x is between 656 (640+16) and 751 (after retrace).
h_video_on is asserted when pixel counter < 640

### Vertical synchronization

beams move from top to bottom
480 lines, 10 line bottom border, 2 line retrace, 33 line top border

vsync goes low when line counter is 490 or 491
v_video_on is high when line counter < 480

### pixel clock

pixel rate = 800 pixels/line * 525 lines/frame * 60 frames/second = 25.2 MHz
To drive the pixel counter, we generate a 25 MHz enable tick

### Memory layout

I initially started with a simplistic 320*240=76800-bit memory, indexed from 0 to 76799

```verilog
localparam RESOLUTION_X = 320;
localparam RESOLUTION_Y = 240;

reg mem [0:RESOLUTION_X*RESOLUTION_Y-1];
```

This lead to a simplistic pixel generator that just reduced the 640x480 resolution to 320x240 by dividing each coordinate by two:

```verilog
module pixel_generator (input clk, input [9:0] pixel_x, input [9:0] pixel_y, output [2:0] rgb);

wire [16:0] current_address = (pixel_y[9:1] * MAX_X) + pixel_x[9:1];

always @(posedge clk) begin
    ...
    address_out <= current_address;
    rgb <= {data_in, data_in, data_in};
```

#### 1-bit vs 8-bit framebuffer

Although this makes it very practical to read a particular display value in a single clock, but impractical to interact with in terms of interfaces - the current serial interface that sends bytes over UART or a future 8-bit soft-CPU, dealing with bytes is nicer than dealing with bits.

To move from this convenient 1-bit interface to 8-bit interface I had to redefine the memory to: 

```verilog
reg [7:0] mem[0:(320*240/8-1)];
```

To cover 320x240 bits we split the framebuffer memory into 9600 words of 8-bits. That also means that one word will cover 8 contiguous pixels.

To calculate the address from the (640,480) range we do


In the spirit of dividing responsibilities into modules I implemented a `m640_to_320` module that produces the `byte` and `bit` part of the framebuffer. We can extract the `bit` part easily as it's just the remainder of (`x` / 2) and 8, then inverted as we store pixel bits in "little endian" ordering. 

Verilog:

```verilog
module m640_to_320 (
	input wire [9:0] pixel_x, //0 to 640
	input wire [9:0] pixel_y, //0 to 480	
	output wire [13:0] address_byte,
	output wire [2:0] address_bit
);
//row_bytes := 320 / 8
//address_byte := pixel_y / 2 * row_bytes
assign address_byte = pixel_y[9:1] * 40 + pixel_x[9:4];
//address_bit := 	~(pixel_x / 2)
assign address_bit = ~pixel_x[3:1];

endmodule
```

The pixel generator then obtains the `address_byte` and `address_bit` from this module. 
As using the block RAM introduces a single clock delay we need to store the value of `address_bit` into a register to be available on the next clock cycle when the memory value actually arrives.

so on every clock cycle the pixel generator module:
-  fetches the correct byte from memory 
-  draws the correct color from currently retrieved byte with the **previous value** of `address_bit`

I spent some time chasing down a bug where some 8-th pixel had incorrect colors as I didn't immediately realize that I needed the 1-clock delay.

TODO image from whatsapp with test pattern
//[!]()


## Screen-to-serial capture

I wrote a little utility in C# that captures the screen, performs dithering and sends the bits over the serial port.

> This is all possible using the standard APIs - we can capture the screen with the `Graphics.FromScreen`, then resize the picture into 320x240, do the dithering by fiddling with the Bitmap's pixels, then write to `System.IO.Ports.SerialPort`.

